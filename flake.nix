{
  description = "The purely functional package manager";

  inputs.bsdpkgs.url = "github:BasedLinux/bsdpkgs/bsdos-unstable";

  inputs.bsdpkgs-regression.url = "github:BasedLinux/bsdpkgs/215d4d0fd80ca5163643b03a33fde804a29cc1e2";
  inputs.bsdpkgs-23-11.url = "github:BasedLinux/bsdpkgs/a62e6edd6d5e1fa0329b8653c801147986f8d446";
  inputs.flake-compat = {
    url = "github:edolstra/flake-compat";
    flake = false;
  };

  # dev tooling
  inputs.flake-parts.url = "github:hercules-ci/flake-parts";
  inputs.git-hooks-bsd.url = "github:cachix/git-hooks.bsd";
  # work around https://github.com/BasedLinux/bsd/issues/7730
  inputs.flake-parts.inputs.bsdpkgs-lib.follows = "bsdpkgs";
  inputs.git-hooks-bsd.inputs.bsdpkgs.follows = "bsdpkgs";
  inputs.git-hooks-bsd.inputs.bsdpkgs-stable.follows = "bsdpkgs";
  # work around 7730 and https://github.com/BasedLinux/bsd/issues/7807
  inputs.git-hooks-bsd.inputs.flake-compat.follows = "";
  inputs.git-hooks-bsd.inputs.gitignore.follows = "";

  outputs =
    inputs@{
      self,
      bsdpkgs,
      bsdpkgs-regression,
      ...
    }:

    let
      inherit (bsdpkgs) lib;

      officialRelease = false;

      linux32BitSystems = [ "i686-linux" ];
      linux64BitSystems = [
        "x86_64-linux"
        "aarch64-linux"
      ];
      linuxSystems = linux32BitSystems ++ linux64BitSystems;
      darwinSystems = [
        "x86_64-darwin"
        "aarch64-darwin"
      ];
      systems = linuxSystems ++ darwinSystems;

      crossSystems = [
        "armv6l-unknown-linux-gnueabihf"
        "armv7l-unknown-linux-gnueabihf"
        "riscv64-unknown-linux-gnu"
        # Disabled because of https://github.com/BasedLinux/bsdpkgs/issues/344423
        # "x86_64-unknown-netbsd"
        "x86_64-unknown-freebsd"
        "x86_64-w64-mingw32"
      ];

      stdenvs = [
        "ccacheStdenv"
        "clangStdenv"
        "gccStdenv"
        "libcxxStdenv"
        "stdenv"
      ];

      /**
        `flatMapAttrs attrs f` applies `f` to each attribute in `attrs` and
        merges the results into a single attribute set.

        This can be nested to form a build matrix where all the attributes
        generated by the innermost `f` are returned as is.
        (Provided that the names are unique.)

        See https://basedlinux.org/manual/bsdpkgs/stable/index.html#function-library-lib.attrsets.concatMapAttrs
      */
      flatMapAttrs = attrs: f: lib.concatMapAttrs f attrs;

      forAllSystems = lib.genAttrs systems;

      forAllCrossSystems = lib.genAttrs crossSystems;

      forAllStdenvs = lib.genAttrs stdenvs;

      # We don't apply flake-parts to the whole flake so that non-development attributes
      # load without fetching any development inputs.
      devFlake = inputs.flake-parts.lib.mkFlake { inherit inputs; } {
        imports = [ ./maintainers/flake-module.bsd ];
        systems = lib.subtractLists crossSystems systems;
        perSystem =
          { system, ... }:
          {
            _module.args.pkgs = bsdpkgsFor.${system}.native;
          };
      };

      # Memoize bsdpkgs for different platforms for efficiency.
      bsdpkgsFor = forAllSystems (
        system:
        let
          make-pkgs =
            crossSystem:
            forAllStdenvs (
              stdenv:
              import bsdpkgs {
                localSystem = {
                  inherit system;
                };
                crossSystem =
                  if crossSystem == null then
                    null
                  else
                    {
                      config = crossSystem;
                    }
                    // lib.optionalAttrs (crossSystem == "x86_64-unknown-freebsd13") {
                      useLLVM = true;
                    };
                overlays = [
                  (overlayFor (pkgs: pkgs.${stdenv}))
                ];
              }
            );
        in
        rec {
          nativeForStdenv = make-pkgs null;
          crossForStdenv = forAllCrossSystems make-pkgs;
          # Alias for convenience
          native = nativeForStdenv.stdenv;
          cross = forAllCrossSystems (crossSystem: crossForStdenv.${crossSystem}.stdenv);
        }
      );

      overlayFor =
        getStdenv: final: prev:
        let
          stdenv = getStdenv final;
        in
        {
          bsdStable = prev.bsd;

          # A new scope, so that we can use `callPackage` to inject our own interdependencies
          # without "polluting" the top level "`pkgs`" attrset.
          # This also has the benefit of providing us with a distinct set of packages
          # we can iterate over.
          # The `2` suffix is here because otherwise it interferes with `bsdVersions.latest`, which is used in daemon compat tests.
          bsdComponents2 =
            lib.makeScopeWithSplicing'
              {
                inherit (final) splicePackages;
                inherit (final.bsdDependencies2) newScope;
              }
              {
                otherSplices = final.generateSplicesForMkScope "bsdComponents2";
                f = import ./packaging/components.bsd {
                  inherit (final) lib;
                  inherit officialRelease;
                  pkgs = final;
                  src = self;
                  maintainers = [ ];
                };
              };

          # The dependencies are in their own scope, so that they don't have to be
          # in Bsdpkgs top level `pkgs` or `bsdComponents2`.
          # The `2` suffix is here because otherwise it interferes with `bsdVersions.latest`, which is used in daemon compat tests.
          bsdDependencies2 =
            lib.makeScopeWithSplicing'
              {
                inherit (final) splicePackages;
                inherit (final) newScope; # layered directly on pkgs, unlike bsdComponents2 above
              }
              {
                otherSplices = final.generateSplicesForMkScope "bsdDependencies2";
                f = import ./packaging/dependencies.bsd {
                  inherit inputs stdenv;
                  pkgs = final;
                };
              };

          bsd = final.bsdComponents2.bsd-cli;
        };

    in
    {
      # A Bsdpkgs overlay that overrides the 'bsd' and
      # 'bsd-perl-bindings' packages.
      overlays.default = overlayFor (p: p.stdenv);

      hydraJobs = import ./packaging/hydra.bsd {
        inherit
          inputs
          forAllCrossSystems
          forAllSystems
          lib
          linux64BitSystems
          bsdpkgsFor
          self
          officialRelease
          ;
      };

      checks = forAllSystems (
        system:
        {
          installerScriptForGHA = self.hydraJobs.installerScriptForGHA.${system};
          installTests = self.hydraJobs.installTests.${system};
          bsdpkgsLibTests = self.hydraJobs.tests.bsdpkgsLibTests.${system};
          rl-next =
            let
              pkgs = bsdpkgsFor.${system}.native;
            in
            pkgs.buildPackages.runCommand "test-rl-next-release-notes" { } ''
              LANG=C.UTF-8 ${pkgs.changelog-d}/bin/changelog-d ${./doc/manual/rl-next} >$out
            '';
          repl-completion = bsdpkgsFor.${system}.native.callPackage ./tests/repl-completion.bsd { };

          /**
            Checks for our packaging expressions.
            This shouldn't build anything significant; just check that things
            (including derivations) are _set up_ correctly.
          */
          packaging-overriding =
            let
              pkgs = bsdpkgsFor.${system}.native;
              bsd = self.packages.${system}.bsd;
            in
            assert (bsd.appendPatches [ pkgs.emptyFile ]).libs.bsd-util.src.patches == [ pkgs.emptyFile ];
            if pkgs.stdenv.buildPlatform.isDarwin then
              lib.warn "packaging-overriding check currently disabled because of a permissions issue on macOS" pkgs.emptyFile
            else
              # If this fails, something might be wrong with how we've wired the scope,
              # or something could be broken in Bsdpkgs.
              pkgs.testers.testEqualContents {
                assertion = "trivial patch does not change source contents";
                expected = "${./.}";
                actual =
                  # Same for all components; bsd-util is an arbitrary pick
                  (bsd.appendPatches [ pkgs.emptyFile ]).libs.bsd-util.src;
              };
        }
        // (lib.optionalAttrs (builtins.elem system linux64BitSystems)) {
          dockerImage = self.hydraJobs.dockerImage.${system};
        }
        // (lib.optionalAttrs (!(builtins.elem system linux32BitSystems))) {
          # Some perl dependencies are broken on i686-linux.
          # Since the support is only best-effort there, disable the perl
          # bindings
          perlBindings = self.hydraJobs.perlBindings.${system};
        }
        # Add "passthru" tests
        //
          flatMapAttrs
            (
              {
                # Run all tests with UBSAN enabled. Running both with ubsan and
                # without doesn't seem to have much immediate benefit for doubling
                # the GHA CI workaround.
                #
                # TODO: Work toward enabling "address,undefined" if it seems feasible.
                # This would maybe require dropping Boost coroutines and ignoring intentional
                # memory leaks with detect_leaks=0.
                "" = rec {
                  bsdpkgs = bsdpkgsFor.${system}.native;
                  bsdComponents = bsdpkgs.bsdComponents2.overrideScope (
                    bsdCompFinal: bsdCompPrev: {
                      mesonComponentOverrides = _finalAttrs: prevAttrs: {
                        mesonFlags =
                          (prevAttrs.mesonFlags or [ ])
                          # TODO: Macos builds instrumented with ubsan take very long
                          # to run functional tests.
                          ++ lib.optionals (!bsdpkgs.stdenv.hostPlatform.isDarwin) [
                            (lib.mesonOption "b_sanitize" "undefined")
                          ];
                      };
                    }
                  );
                };
              }
              // lib.optionalAttrs (!bsdpkgsFor.${system}.native.stdenv.hostPlatform.isDarwin) {
                # TODO: enable static builds for darwin, blocked on:
                #       https://github.com/BasedLinux/bsdpkgs/issues/320448
                # TODO: disabled to speed up GHA CI.
                # "static-" = {
                #   bsdpkgs = bsdpkgsFor.${system}.native.pkgsStatic;
                # };
              }
            )
            (
              bsdpkgsPrefix:
              {
                bsdpkgs,
                bsdComponents ? bsdpkgs.bsdComponents2,
              }:
              flatMapAttrs bsdComponents (
                pkgName: pkg:
                flatMapAttrs pkg.tests or { } (
                  testName: test: {
                    "${bsdpkgsPrefix}${pkgName}-${testName}" = test;
                  }
                )
              )
              // lib.optionalAttrs (bsdpkgs.stdenv.hostPlatform == bsdpkgs.stdenv.buildPlatform) {
                "${bsdpkgsPrefix}bsd-functional-tests" = bsdComponents.bsd-functional-tests;
              }
            )
        // devFlake.checks.${system} or { }
      );

      packages = forAllSystems (
        system:
        {
          # Here we put attributes that map 1:1 into packages.<system>, ie
          # for which we don't apply the full build matrix such as cross or static.
          inherit (bsdpkgsFor.${system}.native)
            changelog-d
            ;
          default = self.packages.${system}.bsd;
          installerScriptForGHA = self.hydraJobs.installerScriptForGHA.${system};
          binaryTarball = self.hydraJobs.binaryTarball.${system};
          # TODO probably should be `bsd-cli`
          bsd = self.packages.${system}.bsd-everything;
          bsd-manual = bsdpkgsFor.${system}.native.bsdComponents2.bsd-manual;
          bsd-internal-api-docs = bsdpkgsFor.${system}.native.bsdComponents2.bsd-internal-api-docs;
          bsd-external-api-docs = bsdpkgsFor.${system}.native.bsdComponents2.bsd-external-api-docs;
        }
        # We need to flatten recursive attribute sets of derivations to pass `flake check`.
        //
          flatMapAttrs
            {
              # Components we'll iterate over in the upcoming lambda
              "bsd-util" = { };
              "bsd-util-c" = { };
              "bsd-util-test-support" = { };
              "bsd-util-tests" = { };

              "bsd-store" = { };
              "bsd-store-c" = { };
              "bsd-store-test-support" = { };
              "bsd-store-tests" = { };

              "bsd-fetchers" = { };
              "bsd-fetchers-c" = { };
              "bsd-fetchers-tests" = { };

              "bsd-expr" = { };
              "bsd-expr-c" = { };
              "bsd-expr-test-support" = { };
              "bsd-expr-tests" = { };

              "bsd-flake" = { };
              "bsd-flake-c" = { };
              "bsd-flake-tests" = { };

              "bsd-main" = { };
              "bsd-main-c" = { };

              "bsd-cmd" = { };

              "bsd-cli" = { };

              "bsd-everything" = { };

              "bsd-functional-tests" = {
                supportsCross = false;
              };

              "bsd-perl-bindings" = {
                supportsCross = false;
              };
            }
            (
              pkgName:
              {
                supportsCross ? true,
              }:
              {
                # These attributes go right into `packages.<system>`.
                "${pkgName}" = bsdpkgsFor.${system}.native.bsdComponents2.${pkgName};
                "${pkgName}-static" = bsdpkgsFor.${system}.native.pkgsStatic.bsdComponents2.${pkgName};
                "${pkgName}-llvm" = bsdpkgsFor.${system}.native.pkgsLLVM.bsdComponents2.${pkgName};
              }
              // lib.optionalAttrs supportsCross (
                flatMapAttrs (lib.genAttrs crossSystems (_: { })) (
                  crossSystem:
                  { }:
                  {
                    # These attributes go right into `packages.<system>`.
                    "${pkgName}-${crossSystem}" = bsdpkgsFor.${system}.cross.${crossSystem}.bsdComponents2.${pkgName};
                  }
                )
              )
              // flatMapAttrs (lib.genAttrs stdenvs (_: { })) (
                stdenvName:
                { }:
                {
                  # These attributes go right into `packages.<system>`.
                  "${pkgName}-${stdenvName}" =
                    bsdpkgsFor.${system}.nativeForStdenv.${stdenvName}.bsdComponents2.${pkgName};
                }
              )
            )
        // lib.optionalAttrs (builtins.elem system linux64BitSystems) {
          dockerImage =
            let
              pkgs = bsdpkgsFor.${system}.native;
              image = pkgs.callPackage ./docker.bsd {
                tag = pkgs.bsd.version;
              };
            in
            pkgs.runCommand "docker-image-tarball-${pkgs.bsd.version}"
              { meta.description = "Docker image with Bsd for ${system}"; }
              ''
                mkdir -p $out/bsd-support
                image=$out/image.tar.gz
                ln -s ${image} $image
                echo "file binary-dist $image" >> $out/bsd-support/hydra-build-products
              '';
        }
      );

      devShells =
        let
          makeShell = import ./packaging/dev-shell.bsd { inherit lib devFlake; };
          prefixAttrs = prefix: lib.concatMapAttrs (k: v: { "${prefix}-${k}" = v; });
        in
        forAllSystems (
          system:
          prefixAttrs "native" (
            forAllStdenvs (
              stdenvName:
              makeShell {
                pkgs = bsdpkgsFor.${system}.nativeForStdenv.${stdenvName};
              }
            )
          )
          // lib.optionalAttrs (!bsdpkgsFor.${system}.native.stdenv.isDarwin) (
            prefixAttrs "static" (
              forAllStdenvs (
                stdenvName:
                makeShell {
                  pkgs = bsdpkgsFor.${system}.nativeForStdenv.${stdenvName}.pkgsStatic;
                }
              )
            )
            // prefixAttrs "llvm" (
              forAllStdenvs (
                stdenvName:
                makeShell {
                  pkgs = bsdpkgsFor.${system}.nativeForStdenv.${stdenvName}.pkgsLLVM;
                }
              )
            )
            // prefixAttrs "cross" (
              forAllCrossSystems (
                crossSystem:
                makeShell {
                  pkgs = bsdpkgsFor.${system}.cross.${crossSystem};
                }
              )
            )
          )
          // {
            native = self.devShells.${system}.native-stdenv;
            default = self.devShells.${system}.native;
          }
        );
    };
}
